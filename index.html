<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>TypeScriptTutorial</title>
    <link rel="stylesheet" href="./style.css">
  </head>

<body class="whole">
    <div class="Heading">
        <h1 id="demo" onclick="turnRed()">TypeScript For Champions</h1>
        <script type="module">
          import {turnRed} from './build/app.js'
          window.turnRed = turnRed;
      </script>
    </div>
    <section class="sans">
      <h2>Important!</h2>
      <p id="comic" onclick="comicSans()">Dislike seeing that glorious comic sans title? <span id="clicky">Click here</span> to remove!</p>
      <script type="module">
        import {comicSans} from './build/app.js'
        window.comicSans = comicSans;
    </script>
    </section>
    <section class="intro">
        <h2>What's TypeScript?</h2>
        <p>
          TypeScript offers all the same features as JavaScript with an
          additional feature: TypeScript's type system. What does this
          system do? In JavaScript variables are not explicitly defined and
          held to a certain type. TypeScript is able to take a value assigned
          to a variable and hold that variable to that type of value, while
          providing the option to explicitly define your variable types.
        </p>
        <img src="https://miro.medium.com/max/1400/1*5yBOYWrozMMR4eOIASxmeg.png" alt="Chart showing relationship between JS and TS">
    </section>
    <section class="types">
        <h2>Types in TypeScript</h2>
        <div class="type-define">
        <h3>How to Define a Type</h3>
          <p>
              While TypeScript is capable of dynamically setting types for primitive
              types and some design patterns, some patterns cannot be inferred automatically.
              To fix this, TypeScript supports an extension of JavaScript allowing
              you to tell TypeScript what the type should be. <br><br>
              The following snippet describes an explicit interface declaration:
          </p>
          <div class="code-ex">
            <p>
              <span class="basic-color">interface</span> <span class="cyan">Student</span> {    <br>
              &ensp;<span class="basic-color">name</span>: <span class="cyan">string</span>;    <br>
              &ensp;<span class="basic-color">id</span>: <span class="cyan">number</span>;      <br>
          }
            </p>
          </div>
          <p>
            You can then force a JavaScript object to adhere to the interface's
            declaration by using the following syntax <span>: TypeName</span>
            after a variable declaration, which can be seen below:
          </p>
          <div class="code-ex">
            <p>
              <span class="basic-color">const</span> <span class="blue">student</span>: <span class="cyan">Student</span> = { <br>
              &ensp;<span class="basic-color">name</span>:  <span class="red">"Linguini"</span>,     <br>
              &ensp;<span class="basic-color">id</span>: <span class="green">0</span>,                  <br>
              };
            </p>
          </div>
          <p>
            If you provide an object that doesn't follow your interface, TypeScript
            will give a warning.
            The same principles apply to with declarations in regards to classes
          </p>
          <div class="code-ex">
            <p>
              <span class="basic-color">interface</span> <span class="cyan">Student</span> {<br>
                &ensp;<span class="basic-color">name</span>: <span class="cyan">string</span>;<br>
                &ensp;<span class="basic-color">id</span>: <span class="cyan">number</span>;<br>
              }<br>
              <br>
              <span class="basic-color">const</span> <span class="blue">student</span>: <span class="cyan">Student</span> = {<br>
                &ensp;<span class="basic-color">username</span>: <span class="red">"Linguini"</span>,<br>
              <div class="code-ex-error">Type '{ username: string; id: number; }' is not assignable to type 'Student'.<br>
                Object literal may only specify known properties, and 'username' does not exist in type 'Student'.</div><br>
                &ensp;<span class="basic-color">id</span>: 0,<br>
              };<br>
            </p>
          </div>
          <img src="https://www.oreilly.com/api/v2/epubs/9781492037644/files/assets/prts_0301.png" alt="Flow chart showing supported types">
        </div>
        <div class="type-compose">
          <h3>Creating Types</h3>
          <p>
            TypeScript can allow you to create more complex types by merging
            simpler ones together. The two simplest ways to achieve this is with
            unions and generics.
          </p>
          <h4>Unions</h4>
          <p>
              Unions allow declaring a type that can be composed of multiple types,
              or to describe what a value is allowed to be in that type.
          </p>
          <div class="code-ex">
            <p>
              <span class="basic-color">type</span> <span class="cyan">orientation</span> = <span class="red">portrait</span> | <span class="red">landscape</span>; <br>
              <span class="basic-color">type</span> <span class="cyan">PositiveEvenNumbersUnderTen</span> = <span class="green">2</span> | <span class="green">4</span> | <span class="green">6</span> | <span class="green">8</span>;
            </p>
          </div>
          <p>
            They can also be used in functions to allow multiple specific types
            to be accepted.
          </p>
          <div class="code-ex">
            <p>
              <span class="basic-color">function</span> <span class="vomit">capitalizeFirst</span>(<span class="basic-color">obj</span>: <span class="cyan">string</span> | <span class="cyan">string</span>[]) {
                ....
              }
            </p>
          </div>
          <h4>Generics</h4>
          <p>
            Generics are able to describe the values that a variable can contain.
            An easy example of this is with arrays, but can be used with your own
            types that you've declared as well.
          </p>
          <div class="code-ex">
            <p>
              <span class="basic-color">type</span> <span class="cyan">StringArray</span> = <span class="cyan">Array</span>&lt<span class="cyan">string</span>&gt; <br>
            </p>
          </div>
          <div class="code-ex">
            <p>
              <span class="basic-color">interface</span> <span class="cyan">Pantalones</span>&lt<span class="cyan">Type</span>&gt { <br>
                &ensp;<span class="vomit">add</span>: (<span class="basic-color">obj</span>: <span class="cyan">Type</span>) <span class="basic-color">=></span> <span class="cyan">void</span>; <br>
                &ensp;<span class="vomit">get</span>: () <span class="basic-color">=></span> <span class="cyan">Type</span>;
              <br>}
            </p>
          </div>
        </div>
    </section>
    <section class="error-checking">
        <h2>Helping With Error Checking</h2>
        <h3>Static Type-Checking</h3>
        <p>
          A static type system describes the shapes and behaviors of
          what your values will be when you run your programs. TypeScript uses
          this information to tell you when you might have problems. For example,
          trying to call something that isn't a function will result in an error
          message before even running your code. This can also be used to find
          errors with calling undefined properties of an object, uncalled functions,
          basic logic errors, and even typos.
        </p>
        <div class="code-ex">
          <p>
            <span class="basic-color">const</span> <span class="blue">message</span> = <span class="red"></span><span class="red">"hello!"</span>; <br><br>
            <span class="vomit">message</span>();
            <div class="code-ex-error">
              This expression is not callable.
              Type 'String' has no call signatures.
            </div>
          </p>
        </div>
    </section>
    <section class="Types For Tooling">
      <h2>Tools for Types</h2>
      <h3>TypeScript Compiler (tsc)</h3>
        <img src="https://devopedia.org/images/article/165/6445.1554799186.jpg" alt="Diagram of TS compilation to TS">
        <p>
          The TypeScript Compiler can find errors in runtime based on what Types
          and how many you provide to the program when you run it. You can get 
          the TypeScript compiler by installing it via npm:
        </p>
        <div class="code-ex">
          <p>
            npm install -g typescript
          </p>
        </div>
      <h3>Explicit Types</h3>
        <p>
          You can add explicit types to a function or variable by adding
          what is called <em>type annotations</em> as shown below. 
        </p>
        <div class="code-ex">
          <p>
            <span class="basic-color">function</span> <span class="vomit">greet</span>(<span class="basic-color">person</span>: <span class="cyan">string</span>, <span class="basic-color">date</span>: <span class="cyan">Date</span>) {<br>
              &ensp;<span class="basic-color">console</span>.<span class="vomit">log</span>(<span class="red">`Hello</span> <span class="basic-color">${person}</span>, <span class="red">today is</span> <span class="basic-color">${date</span>.<span class="vomit">toDateString</span>()<span class="basic-color">}</span><span class="red">!`</span>);<br>
            }
          </p>
        </div>
        <p>
          After adding these annotations,
          TypeScript is able to find cases where these variables or functions were 
          used incorrectly or called with improper types. TypeScript can also infer
          types for you for certain types, such as directly assigning a variable with
          a string will define that the variable has the string type.
        </p>
        <div class="code-ex">
          <p>
            <span class="basic-color">function</span> <span class="vomit">greet</span>(<span class="basic-color">person</span>: <span class="cyan">string</span>, <span class="basic-color">date</span>: <span class="cyan">Date</span>) {<br>
              &ensp;<span class="basic-color">console</span>.<span class="vomit">log</span>(<span class="red">`Hello</span> <span class="basic-color">${person}</span>, <span class="red">today is</span> <span class="basic-color">${date</span>.<span class="vomit">toDateString</span>()<span class="basic-color">}</span><span class="red">!`</span>);<br>
            }<br>
             <br>
             <span class="vomit">greet</span>(<span class="red">"Maddison"</span>, <span class="cyan">Date</span>());<br>
            <div class="code-ex-error">
              Argument of type 'string' is not assignable to parameter of type 'Date'.
            </div>
          </p>
        </div>
        <p>
          While the above example may look right, calling Date() actually returns a string, 
          which is not accepted by the above function.
        </p>
        
      <h3>Strictness</h3>
        <p>
          Changing your strictness dictates how much TypeScript will check for you.
          While some may want looser strictness, whether out of preference or because
          of migrating existing JavaScript where you may get many errors that you may
          prefer to ignore, many prefer to have TypeScript validate as much as it can
          as soon as it can. TypeScript has several strictness flags that can be toggled,
          and while you can toggle them all on with "strict": true in a tsconfig.json,
          you may prefer to toggle the individually. The two biggest flags are noImplicitAny
          and strictNullChecks.
        </p>
      <h4>noImplicitAny</h4>
        <p>
          This makes it so that TypeScript never defaults a type to any after failing
          to infer a type. In areas where this may occur, an error is thrown for any
          variable that has type any.
        </p>
      <h4>strictNullChecks</h4>
        <p>
          This flag makes handling null and undefined more explicit so you know
          that these cases are handled properly.
        </p>
      
    </section>
    <section class="partyZone">
      <h1>PARTY ZONE</h1>
      <p>Congrats for making it to the end, enjoy a well earned party square. (Click for fun)</p>
      <div id="partySquare" onclick="partyTime()"></div>
      <script type="module">
        import {partyTime} from './build/app.js'
        window.partyTime = partyTime;
      </script>
    </section>
    <footer>
      <p>
        This tutorial contains material from the following guides:<br>
        <a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html">TypeScript for JavaScript Programmers</a><br>
        <a href="https://www.typescriptlang.org/docs/handbook/2/basic-types.html">TypeScript Basics</a>
      </p>

    </footer>
</body>

</html>